#

## 注意事项

1. 如果使用的是函数返回值，在顶层函数中一定要`return`，否则会得到`NaN`

   ```js
   function f1(n) {
      retrun resolve(n); // 这里千万千万不要忘记了 return
   }

   function resolve(n) {
      ...
      return res;
   }

   export default {
      f1
   }
   ```

## 字符串

1. num 转 二进制

   ```js
   parseInt(num).toString(2);
   ```

   二进制法则

   ```js
   let binary = "";
   while (num) {
     binary = (num % 2) + binary;
     num = Math.floor(num / 2);
   }
   ```

2. 二进制转十进制

   语法：`parseInt(string, radix)`, 默认是 10 进制

   ```js
   parseInt(binary, 2);
   ```

3. 注意 JS 中除法 一定要加 `Math.floor`
   有两种写法可以达到和`Math.floor`一样的效果：

   - `>>> 0`: `temp = (temp / 10) >>> 0`
   - `~~`: `temp = ~~(temp / 10)`

4. 字符串方法

   - `split(symbol)` 字符串分隔成数组
   - `slice(start, end)` 截取[start, end)范围内数组，这个方法数组和字符串都能使用

5. 检测字符串是否有重复子串，采用 `后缀字符串`

   后缀字符串的具体做法：

   先遍历字符串，统计收集所有字符的后缀 abcdefg
   a -> abcdefg

   b -> bcdefg

   c -> cdefg

   然后将后缀字符按字典顺序排序一下，这是将相近后缀排在一起，方便后面进行比对
   比对后缀字符串数组，拿当前的和前一个比对。题目要求长度不大于 2 的重复子串，所以我们取长度为 3 的字符进行匹配就行，有相等的就说明有重复子串了。

6. 基本匹配正则

   - 匹配英文： `[A-Za-z]`
   - 匹配数字：`/\d/`
   - 匹配空白符： `/\s/`
   - 不是数字、大小写字母和下划线：`/\W/` 等价`[^0-9a-zA-Z_]`

7. 涉及 ASCII 码的牢记两个方法

```js
String.fromCodePoint(97); // a

"a".codePointAt(0); // 97
```

## 数组

1. sort((a, b) => a - b)

   ```js
   arr.sort((a, b) => {
     if (a > b) return 1;
     if (a < b) return -1;
     return 0;
   });
   ```

   简写形式:

   - `(a, b)=> a - b` 升序
   - `(a, b) => b - a` 降序

2. `concat()`

   拼接数组的正确用法: `arr = arr.concat(otherArr);`

3. 创建数组

   - 一维数组：`const arr = Array(n).fill(1)`;
   - 二维数组：`const arr = Array(n).fill().map(i => Array(m).fill(1))`
   - 二维数组：`const arr = Array.from(Array(m+1), () => Array(n+1).fill(0))`

4. 避免数组引用修改，导致最终结果和预期不一致

   ```js
   // res 放入 track []
   res.push(track);

   // 可是track在某处会被修改
   track.pop();
   ```

   所以正确用法 `res.push([...track])`;

5. `Array.prototype.reduce()` 必须要确保数组有长度 > 1, 否则无效。

## 数值

1. Infinity 可以表示正无穷
2. -Infinity 可以表示负无穷
3. 对于比较大小可以使用 `Math.max()` 和 `Math.min()`
   - `max(a, b, c)` 可以得到 a,b,c 三个中最大的
4. `num & 1 = true` => num 是奇数

## 经典题

1. 二进制中 1 的个数
   不要去转换 n 成二进制，直接使用位运算。

   > 举个例子：一个二进制数 1100，从右边数起第三位是处于最右边的一个 1。减去 1 后，第三位变成 0，它后面的两位 0 变成了 1，而前面的 1 保持不变，因此得到的结果是 1011.我们发现减 1 的结果是把最右边的一个 1 开始的所有位都取反了。这个时候如果我们再把原来的整数和减去 1 之后的结果做与运算，从原来整数最右边一个 1 那一位开始所有位都会变成 0。如 1100&1011=1000.也就是说，把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成 0.那么一个整数的二进制有多少个 1，就可以进行多少次这样的操作。

   ```js
   function NumberofOne(n) {
     let res = 0;

     while (n) {
       res++;
       n &= n - 1;
     }
     return res;
   }
   ```

2.

## 链表类题

- 双指针
  - 快慢双指针
- 虚拟头结点
- 环形结点，快指针走两步，慢指针走一步，如来快慢指针相遇说明有环；在相遇的时候，如果慢指针从 head 开始，快指针从相遇点开始，两个指针都走一步，快慢指针再次相遇的时候就是环的入口点。

```js
function detectCycle(head) {
  if (!head || !head.next) return null;

  let slow = head.next,
    fast = head.next.next;

  // 快指针还没走完，并且快指针和慢指针还没相遇
  while (fast && fast.next && fast !== slow) {
    slow = slow.next;
    fast = fast.next.next;
  }
  // 说明无环，可以走到底
  if (!fast || !fast.next) return null;
  b;

  // 下面有环，就要输出第一个入环点
  slow = head;
  while (fast !== slow) {
    slow = slow.next;
    fast = fast.next;
  }

  return slow;
}
```
